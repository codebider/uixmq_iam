/* tslint:disable */
import WaitFor from "framework/WaitFor";
import {Entity} from "domain/Entity";
import {ObjectNotFoundException} from "domain/Exception";


export interface CrudGateway<T extends Entity> {
    create(object: T): T;
    update(object: T): T;
    deleteById(id: string): void;
    findAll(): T[];
    findAllWithFilter(filter: any, start?: number, limit?: number, sort?: any): T[]; //find
    findWithAttributes(filter: any, sort?: any, limit?: number , page?: number ): T[];
    findById(id: string): T; //findOneById
    findWithFilter(filter: any): T; //findOne
    delete(filter: any): void;
    softDeleteById(id: string);
    countAll(): number;
    count(filter: any): number;
    updateAttributes(dto: any);
    findByIdWithRelation(id: string, relations: any[]);
    findAllWithFilterAndRelations(filter: any, relations: any[], start?: number, limit?: number, sort?: any);
    findWithFilterAndRelations(filter: any, relations: any[]);
    updateOneAttributesList(filter: any, dto: any);
    findAndCountAllWithRelations(filter: any, relations: any[], start?: number, limit?: number, sort?: any);
    findAndCountAll(filter: any, start?: number, limit?: number, sort?: any);
}

export function MakeCrudGateway<T extends Entity>(schema: any, fromActiveRecord: (record: any) => T, wait?: any): CrudGateway<T> {
    return new CrudGatewayImpl<T>(schema, fromActiveRecord, wait || WaitFor);
}

class CrudGatewayImpl<T extends Entity> implements CrudGateway<T> {

    private wait: any;
    private schema: any;
    private fromActiveRecord: (record: any) => T;

    constructor(schema: any, fromActiveRecord: (record: any) => T, wait: any) {
        this.wait = wait;
        this.fromActiveRecord = fromActiveRecord;
        this.schema = schema;
    }

    create(object: T) {
        return <T>this.wait(new Promise((resolve: any, reject: any) => {
            object.record.save({}).then((result) => {
                resolve(this.fromActiveRecord(object.record.get({
                    plain: true
                })));
            }).catch((err) => {
                reject(err);
            })
        }));
    }

    update(object: T) {
        const dto = object.record;
        return <T>this.wait(new Promise((resolve: any, reject: any) => {
            this.schema.update(dto, { where: { id: object.getId() }})
            .then((count) => { resolve(object) })
            .catch((err) => { reject(err) })
        }));
    }

    updateOneAttributesList(filter: any, dto: any) {
        const fields = Object.keys(dto);
        return this.wait(this.schema.update(dto, {where: filter, fields: fields}))
    }

    deleteById(id: string) {
        return this.wait(new Promise((resolve: any, reject: any) => {
            this.schema.destroy({where: {id: id}})
            .then((count) => {resolve(count)})
            .catch((err) => {reject(err)});
        }));
    }

    findAll() {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.findAll({raw: true})
            .then((docs) => { 
                let result = [];
                result = docs.map((doc) => {
                    return this.fromActiveRecord(doc);
                });
                resolve(result);
            }).catch((err) => {reject(err)})
        }));
    }

    findById(id: string) {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.findOne({where: {id}, raw: true})
            .then((doc) => {
                if(!doc) throw new ObjectNotFoundException('', "ObjectNotFound");
                resolve(this.fromActiveRecord(doc));
            }).catch((err) => {reject(err)})
        }));
    }

    findByIdWithRelation(id: string, relations: any[]) {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.findOne({
                where: {id},
                include: relations
            }).then((doc) => {
                if(!doc) throw new ObjectNotFoundException('', "ObjectNotFound");
                resolve(doc);
            }).catch((err) => {
                reject(err);
            })
        }));
    }

    findAllWithFilter(filter: any, start?: number, limit?: number, sort?: any) {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.findAll({
                where: filter,
                raw: true,
                offset: start,
                limit: limit,
                order: sort || [['createdAt', 'DESC']]
            })
            .then((docs) => {
                let result = [];
                result = docs.map((doc) => {
                    return this.fromActiveRecord(doc);
                });
                resolve(result);
            }).catch((err) => {reject(err)})
        }));
    }

    findAllWithFilterAndRelations(filter: any, relations: any[], start?: number, limit?: number, sort?: any) {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.findAll({
                where: filter,
                include: relations,
                offset: start,
                limit: limit,
                order: sort || [['createdAt', 'DESC']]
            })
            .then((docs) => {
                resolve(docs);
            }).catch((err) => {reject(err)});
        }))
    }

    findWithFilter(filter: any) {
        const record = this.wait(new Promise((resolve, reject) => {
            this.schema.findOne({where: filter, raw: true })
            .then((doc) => {
                resolve(doc);
            }).catch((err) => {
                reject(err);
            })
        }));
        if (!record) { throw new ObjectNotFoundException('', "ObjectNotFound"); }
        return this.fromActiveRecord(record);
    }

    findWithFilterAndRelations(filter: any, relations: any[]) {
        const record = this.wait(new Promise((resolve, reject) => {
            this.schema.findOne({where: filter, include: relations })
            .then((doc) => {
                resolve(doc);
            }).catch((err) => {
                reject(err);
            })
        }));
        if (!record) { throw new ObjectNotFoundException('', "ObjectNotFound"); }
        return record;
    }

    delete(filter: any) {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.destroy({where: filter})
            .then((count) => {resolve(count)})
            .catch((err) => {reject(err)});
        }));
    }
    
    softDeleteById(id: string) {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.destroy({where: { id: id }, paranoid: true})
            .then((count) => {resolve(count)})
            .catch((err) => {reject(err)});
        }));
    }

    countAll() {
        return this.wait(this.schema.count({raw: true}));
    }

    count(filter: any) {
        return this.wait(this.schema.count({where: filter, raw: true}));
    }

    updateAttributes(dto: any) {
        const fields = Object.keys(dto);
        return this.wait(this.schema.update(dto, {where: {id: dto.id}, fields: fields}))
    }

    findWithAttributes(filter: any = {}, sort: any = [['createdAt', 'DESC']], limit: number = 1, page: number = 5) {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.findAll({
                where: filter,
                limit: limit,
                offset: (page - 1) * limit,
                order: sort,
                raw: true
            }).then((docs) => {
                const result = docs.map((doc) => {
                    return this.fromActiveRecord(doc);
                });
                resolve(result);
            }).catch((err) => {
                reject(err);
            })
        }))
    }

    findAndCountAllWithRelations(filter: any, relations: any[], start?: number, limit?: number, sort?: any) {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.findAndCountAll({
                where: filter,
                include: relations,
                offset: start,
                limit: limit,
                order: sort || [['createdAt', 'DESC']]
            })
            .then((data) => {
                resolve(data);
            }).catch((err) => {reject(err)});
        }))
    }

    findAndCountAll(filter: any, start?: number, limit?: number, sort?: any) {
        return this.wait(new Promise((resolve, reject) => {
            this.schema.findAndCountAll({
                where: filter,
                offset: start,
                limit: limit,
                order: sort || [['createdAt', 'DESC']],
                raw: true
            })
            .then((docs) => {
                const data = docs.rows.map((doc) => {
                    return this.fromActiveRecord(doc);
                });
                resolve({
                    data: data,
                    count: docs.count
                })
            }).catch((err) => {reject(err)});
        }))
    }
}
