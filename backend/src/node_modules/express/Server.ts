/* tslint:disable */
import express = require("express");
import bodyParser = require("body-parser");
import logger from "framework/Logger";
const _wait = require("wait.for");
const _expressRouter = express.Router();
const _expressRouterPrivate = express.Router();
import {RoutingOption} from "../domain/RoutingOption";
import {UnauthorizationException} from "domain/Exception";
import {MakeJWT} from "framework/JWT";
const cors = require('cors');
import { MakeUserGateway } from "gateway/user/UserGateway";

export default class Server {

    private listener: any;
    private exp: any;
    private wait: any;
    private routers: RoutingOption[];
    private privateRouters: RoutingOption[];
    private expressRouter: any;
    private expressRouterPrivate: any;

    constructor(
        routers: RoutingOption[] = [], 
        privateRouters: RoutingOption[] = [],
        listener = express(),
        exp = express,
        wait = _wait,
        expressRouter = _expressRouter,
        expressRouterPrivate = _expressRouterPrivate
    ) {
            this.listener = listener;
            this.exp = exp;
            this.wait = wait;
            this.routers = routers;
            this.privateRouters = privateRouters;
            this.expressRouter = expressRouter;      
            this.expressRouterPrivate = expressRouterPrivate;
    }

    public listen(port: number) {
        port = port || 3333;
        this.listener.use(bodyParser.json({ limit: "50mb" }));
        this.listener.use(bodyParser.urlencoded({ extended: true, limit: "50mb" }));
        this.listener.use(cors());

        this.listener.use((req: any, res: any, next: any) => {
            this.wait.launchFiber(next);
        });

        this.routers.forEach((router: RoutingOption) => {
            const folder = router.root;
            const routing = router.routing;
            routing.fillRoutes(this.expressRouter, this.getHandlers(routing));
            this.listener.use(folder, this.expressRouter);
        });

        this.expressRouterPrivate.use(this.validateAuthenticate);

        this.privateRouters.forEach((router: RoutingOption) => {
            const folder = router.root;
            const routing = router.routing;
            routing.fillRoutes(this.expressRouterPrivate, this.getHandlers(routing), this.getMiddlewares(routing));
            this.listener.use(folder, this.expressRouterPrivate);
        });
        
        this.listener.use((err: any, req: any, res: any, next: any) => {
            err.message = err.key;
            console.log(err);
            console.log(err.stack);
            res.status(err.statusCode).send(JSON.stringify(err));
            next();
        });

        this.listener.listen(port);
        
        logger.info("---", "BACKEND SERVER IS RUNNING ON", port, "---");
    }

    private getHandlers(routing: any) {
        const handler = routing.handlers();
        Object.keys(handler).map((key: any) => {
            const fn = handler[key];
            handler[key] = (req: any, res: any) => res.json(fn(req, res));
        });

        return handler;
    }

    private getMiddlewares(routing: any) {
        if (!routing.middlewares) {
            return null;
        }
        const middlewares = routing.middlewares();
        Object.keys(middlewares).map((key: any) => {
            const fn = middlewares[key];
            middlewares[key] = (req: any, res: any, next: any) => fn(req, res, next);
        });

        return middlewares;
    }

    private validateAuthenticate(req, res, next){
        const tokenData = MakeJWT().decode(req.headers.authorization);
        if(tokenData.error){
            throw new UnauthorizationException("", "Unauthorization.AuthorizationisNotProvide");
        } else if(tokenData.ttl + (tokenData.iat * 1000) < new Date().getTime()){
            throw new UnauthorizationException("", "Unauthorization.TokenisExpire");
        }
        else{
            req.user = MakeUserGateway().findOneById(tokenData.uId);
            next();
        }
    }
}
